---
layout: post
title: "Why webpack configs often look so chaotic"
date: 2019-01-20 12:00:00 +0200
categories: culture
author_name: Andreas Geier
author_url : /author/andreasgeier
author_avatar: andreasgeier
read_time : 10
excerpt: "Why do webpack config files usually look so complicated? If you ever asked yourself this question read this post to find out."
feature_image: posts/2019-01-20-webpack/header.jpg
---

TODOS:
- add links to repository/commits so that it is easier to follow along
- write filename before each snippet
- make sure to shortly introduce things like `npx` or other commands
- add language hint to all code snippts so the highlighting is working

Ever wondered why `webpack.config.js` tends to get out of control very fast? Why does it have so many dependencies? Why does it need so many config lines? Some of our `webpack.config.js` files at HolidayCheck are really huge and I never understood why. I also never was able to write one from scratch or didn't even understand what most of the lines did. Until I decided to set up a project from scratch and build this config file line by line.
It helped me understanding what each line did, why it is necessary and what benefit it gives us. Want to learn that too? Keep on reading.

## The project

Let's build a very simple application and imagine that one day your Product Owner tells you that we need a simple webpage that shows the name of a hotel and a description for that hotel. Sound like a very easy MVP and it is very easy. So let's build it.
You can also follow along by looking at [this example repository](https://github.com/functino/webpack-intro).

### The MVP

Well all we need to do is display some text. So we can do that by simply using HTML:

```HTML
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Webpack Introduction</title>
  </head>
  <body>
      <h1>Dana Beach Resort</h1>
      <p>Das modern ausgestattete 5-Sterne-Hotel Dana Beach Resort liegt direkt am eigenen Sandstrand, erbaut in einem einzigartigen Stil, mit hohem Komfort, mit bestem Service und einem umfangreichen Sport- & Freizeitangebot.</p>
  </body>
</html>
```

and that's it. But this is how you would've done this 20 years ago. Today we can use JavaScript and css. So let's do that:

```html
    <div id="root"></div>
    <script>
        var hotel = {
            id: '1aa4c4ad-f9ea-3367-a163-8a3a6884d450',
            name: 'Dana Beach Resort',
            description: 'Das modern ausgestattete 5-Sterne-Hotel Dana Beach Resort liegt direkt am eigenen Sandstrand, erbaut in einem einzigartigen Stil, mit hohem Komfort, mit bestem Service und einem umfangreichen Sport- & Freizeitangebot.'
        };

        var html = '<div><h1>' + hotel.name + '</h1><p>' + hotel.description + '</p></div>';    
        document.getElementById('root').innerHTML = html;
    </script>
    <style>
        html body {
            color: #0058a3;
            font-family: Arial;
        }
    </style>
```

Of course using inline scripts and inline styles is not what good developers do. So let's extract those:

```js
var hotel = {
    id: '1aa4c4ad-f9ea-3367-a163-8a3a6884d450',
    name: 'Dana Beach Resort',
    description: 'Das modern ausgestattete 5-Sterne-Hotel Dana Beach Resort liegt direkt am eigenen Sandstrand, erbaut in einem einzigartigen Stil, mit hohem Komfort, mit bestem Service und einem umfangreichen Sport- & Freizeitangebot.'
};

var html = '<div><h1>' + hotel.name + '</h1><p>' + hotel.description + '</p></div>';    
document.getElementById('root').innerHTML = html;
```

```css
html body {
    color: #0058a3;
    font-family: Arial;
}
```

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Webpack Introduction</title>
        <link rel="stylesheet" href="./src/index.css"></link>
  </head>
  <body>
      <div id="root"></div>
      <script src="./src/index.js"></script>
  </body>
</html>
```

Already way better and easier maintainable. Right? Right!

### The first feature request
Our PO found out that it is a bit noisy to show all that information. Now they want to initially only show a button that when clicked reveals the information. Luckily we already introduce JS so it is easy to change:

```js
var hotel = {
    id: '1aa4c4ad-f9ea-3367-a163-8a3a6884d450',
    name: 'Dana Beach Resort',
    description: 'Das modern ausgestattete 5-Sterne-Hotel Dana Beach Resort liegt direkt am eigenen Sandstrand, erbaut in einem einzigartigen Stil, mit hohem Komfort, mit bestem Service und einem umfangreichen Sport- & Freizeitangebot.'
};

document.getElementById('root').innerHTML = '<button id="showButton">Show Hotel</button>';

document.getElementById('showButton').addEventListener('click', function() {
    var html = '<div><h1>' + hotel.name + '</h1><p>' + hotel.description + '</p></div>';
    document.getElementById('root').innerHTML = html;
});
```

Hm, easy enough. But our index.js is getting quite big. Why don't we extract the data into it's own file?

```js
# hotel.js
var hotel = {
    id: '1aa4c4ad-f9ea-3367-a163-8a3a6884d450',
    name: 'Dana Beach Resort',
    description: 'Das modern ausgestattete 5-Sterne-Hotel Dana Beach Resort liegt direkt am eigenen Sandstrand, erbaut in einem einzigartigen Stil, mit hohem Komfort, mit bestem Service und einem umfangreichen Sport- & Freizeitangebot.'
};
```

```js
# index.js
document.getElementById('root').innerHTML = '<button id="showButton">Show Hotel</button>';

document.getElementById('showButton').addEventListener('click', function() {
    var html = '<div><h1>' + hotel.name + '</h1><p>' + hotel.description + '</p></div>';
    document.getElementById('root').innerHTML = html;
});
```

And include both in our html file:

```html
<script src="./src/hotel.js"></script>
<script src="./src/index.js"></script>
```

Better.

But our PO has the next feature request:

### The description is too long - ellipsize it...

Well we could now implement a function that ellipisizes our code. But we are working with JavaScript and there are thousands of modules that already do something like this. So we just search for one and introduce an npm module:

```
npm init # initialize npm, this will add a package.json
npm install ellipsize --save # this will install the ellipsize package
```

And now we can simply use it in our index.js file:

```js
var ellipsize = require('ellipsize');

document.getElementById('root').innerHTML = '<button id="showButton">Show Hotel</button>';

document.getElementById('showButton').addEventListener('click', function() {
    var html = '<div><h1>' + hotel.name + '</h1><p>' + ellipsize(hotel.description, 50) + '</p></div>';
    document.getElementById('root').innerHTML = html;
});
```

Of course this doesn't work. The browser doesn't know what `require` is. We need to bundle our "application". This is where webpack comes into play.

So let's install webpack (we're going to install webpack 3, because when I initially created this guide webpack 4 wasn't out there. There are some things that are no longer necessary for webpack 4 - I'll show you in the end):

`npm install webpack@3 --save-dev`

And instead of directly including `index.js` in our html file we are going to include the build artifact that webpack will create for us: `dist/main.js`:

```html
<script src="./dist/main.js"></script>
```

And while we're at it: instead of adding a script tag for `hotel.js` we're going to require that one in index.js:

```js
# index.js
var ellipsize = require('ellipsize');
var hotel = require('./hotel');
...
```

```js
# hotel.js
module.exports = {
    id: '1aa4c4ad-f9ea-3367-a163-8a3a6884d450',
    name: 'Dana Beach Resort',
    description: 'Das modern ausgestattete 5-Sterne-Hotel Dana Beach Resort liegt direkt am eigenen Sandstrand, erbaut in einem einzigartigen Stil, mit hohem Komfort, mit bestem Service und einem umfangreichen Sport- & Freizeitangebot.'
}
```

And now all we need to do is run wepback!?

`node_modules/bin/webpack` or `npx webpack` should do the trick, right?

Well actually no. You'll see this error message:

```
No configuration file found and no output filename configured via CLI option.
A configuration file could be named 'webpack.config.js' in the current directory.
Use --help to display the CLI options.
```

So it needs an output filename to know where it should put our resulting bundle:

`npx webpack --outputFilename=./dist/main.js`

And the error message changes to:

```
No configuration file found and no entry configured via CLI option.
When using the CLI you need to provide at least two arguments: entry and output.
A configuration file could be named 'webpack.config.js' in the current directory.
Use --help to display the CLI options.
```

Well OK, it also needs an entry point that tells it which file it should bundle:

`npx webpack --outputFilename=./dist/main.js --entry ./src/index.js`

Aaaand finally: success. It will create a `main.js` now and we can open the application in the browser. Awesome.

Instead of passing in `--outputFilename` and `--entry` all the time we can also create a `webpack.config.js`:

```
# webpack.config.js
const path = require('path');
module.exports = {
    entry: './src/index',
    output: {
        filename: 'main.js',
        path: path.resolve(__dirname, 'dist')
    }
};
```

And then just invoke `npx webpack`. Or even better use npm run scripts in our package.json to allow us to just run
`npm run build` to build once or `npm run watch` to have a file watcher on our source code and automatically recreate the main.js file whenever we change something:

```js
{
  "name": "webpack-intro",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "build": "webpack",
    "watch": "webpack --watch"
  },
  "keywords": [

  ],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "ellipsize": "0.0.3",
    "webpack": "^3.11.0"
  }
}
```

## Making it more modern

Since we're good developers we want to keep up with all the new cool features that JavaScript offers us. Like arrow-functions, const and let, classes, import, template literals... We'll let's refactor our code:

```js
# index.js
import ellipsize from 'ellipsize';
import hotel from './hotel';

document.getElementById('root').innerHTML = '<button id="showButton">Show Hotel</button>';

document.getElementById('showButton').addEventListener('click', () => {
    const { name, description } = hotel;
    const html = `<div>
        <h1>${name}</h1>
        <p>${ellipsize(description, 50)}</p>
    </div>`;
    document.getElementById('root').innerHTML = html;
});
```

Great. We're cutting edge now. But it turns out that our application stopped working in older browsers that do not yet support those features. If you take a look at the created `main.js` file you'll notice that it looks pretty much like what we've written. And older browsers just don't know what a `=>` is...

So we need to transpile our amazing modern source code to boring old source code. That's where babel comes into play:

## babel

Babel is used to transpile modern code like es6 into boring old code (e.g. es5). So let's install babel and configure it.
To do that we need to understand one concept in webpack: loaders. What is a loader? Everytime webpack is loading a file it will check if you have any loaders configured. If so it will pass control to that loader. One such loader is babel-loader. babel-loader needs babel-core. So let's install both

`npm install babel-loader babel-core --save-dev`:

And add a configuration to our webpack.config.js:
```js
const path = require('path');
module.exports = {
    entry: './src/index',
    output: {
        filename: 'main.js',
        path: path.resolve(__dirname, 'dist')
    },
    module: {
        loaders: [
            {
                test: /\.js$/, // we want to apply this loader to all javascript files
                use: 'babel-loader'
            }
        ]
    }
};
```

Looks good. Let's run `npm run build` and check how `main.js` looks now. Unfortunately it still includes `() =>` and it didn't transpile anything. This is because by default babel-loader won't do anything. You need to tell it what you want to have transpiled.
One way to do that is to use a so called `preset` in babel. A preset is basically a set of configurations. One such preset is
`babel-preset-env`. Let's install it

`npm i babel-preset-env --save-dev`

And configure it. To do that we're going to create a `.babelrc`:

```json
{
    "presets": ["env"]
}
```

And if we know run `npm run build` it works. `() => ` is transpiled to something that even old browsers understand. Phew.

### Of course we want to use react

All the cool kids use react. And since we're building an application we should use react as well. So let's refactor our index.js file to use react.

First of all we have to install react and react-dom:
`npm i react react-dom --save`

And the source code changes to:
```
import React from 'react';
import ReactDOM from 'react-dom';
import ellipsize from 'ellipsize';

import hotel from './hotel';

class App extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            hotel: false
        };
    }
    render() {
        if (this.state.hotel) {
            const { name, description } = this.state.hotel;
            return (<div>
                <h1>{name}</h1>
                <p>{ellipsize(description)}</p>
            </div>);
        }
        return (<button onClick={() => this.setState({ hotel: hotel })}>Show Hotel</button>);
    }
}

ReactDOM.render(<App />, document.getElementById('root'));
```

Amazing. Much easier to understand - at least for someone that likes to use react for such a tiny application ;)

But if we know open our application in the browser again it stops working. Why? Because the browser doesn't understand react's `jsx` and we did not configure anything to transpile jsx to "normal" javascript.

Luckily there is a preset for babel to do exactly that:

`npm i babel-preset-react --save-dev`

And if we add that to our .babelrc confguration:

```
{
    "presets": ["env", "react"]
}
```

Everything is working again.


### We're transpiling our JavaScript - let's to the same for CSS!

Well who uses CSS when you can use something like Sass and .scss? Exactly. Nobody! What do we need to do to use scss?
First of all embedding css via ` <link rel="stylesheet" href="./src/index.css"></link>` is lame - we should import it in our index.js file instead:

```
# index.js
import './index.scss';
# ...
```

And then we create an index.scss that uses all those amazing sass feature like nesting:

```
html {
    body {
        color: #0058a3;
        font-family: Arial;
        button {
            font-size: 30px;
            padding: 20px;
        }    
    }
}
```

Remember how we needed to configure a loader for .js files to transpile them? We need to do the same for our css now. So let's add another entry:

```
const path = require('path');
module.exports = {
    ...
    module: {
        loaders: [
            {
                test: /\.js$/,
                use: 'babel-loader'
            },
            {
                test: /\.scss$/, # this loader should be applied to all .scss files
                use: [
                    "style-loader", # this loader is injecting the styles into the DOM in the browser
                    "css-loader", # this loader makes it possible to use imports() and url() in our css
                    "sass-loader" # this loader will transpile our scss to css.
                ]
            }
        ]
    }
};
```

Of course for this to work we need to install those packages. node-sass is a peer dependency of sass-loader that we'll need to install additionally:

`npm i style-loader css-loader sass-loader node-sass --save-dev`

And if we open our application now you can check in your inspector that it does not download any .css file anymore and if you look in the DOM / Elements inspector you'll see that it injected a style-tag. Awesome.

But how does it work? Just open main.js and search for your css. You'll find a code block where you will see our css code right in our .js file. That makes our JS-file bigger and it prevents the browser from downloading css and js in parallel.
We want to have our .css file again!

### Extracting CSS into a .css files

So we want to keep using sass but we also want to have a .css file that can be imported in our html with:

` <link rel="stylesheet" href="./dist/main.css"></link>`

And we're lucky: There is a plugin for webpack for exactly this purpose:

`npm i extract-text-webpack-plugin --save-dev`

We're learning our second webpacky concept besided modules now: Plugins.

Just add it to our webpack configuration:

```
const path = require('path');
const ExtractTextPlugin = require('extract-text-webpack-plugin');

module.exports = {
    entry: './src/index',
    output: {
        filename: 'main.js',
        path: path.resolve(__dirname, 'dist')
    },
    module: {
        loaders: [
            {
                test: /\.js$/,
                use: 'babel-loader'
            },
            {
                test: /\.scss$/,
                use: ExtractTextPlugin.extract({ # we'll additionally use this plugin when loading styles
                    fallback: "style-loader", # injecting styles into the DOM is now just a fallback in case the css generation fails
                    use: [
                        "css-loader", # and we still want to use our css and sass-loader
                        "sass-loader"
                    ]
                })
            }
        ]
    },
    plugins: [
        new ExtractTextPlugin('main.css') # we need to tell the plugin we're the build result should be stored
    ]
};
```

Check the result by looking into your chrome dev tools: We're loading a main.css again and we no longer have any CSS in our .js file. Success!

### Make webpack less noisy

By default webpack outputs a bunch of information whenever it builds something. Often that output is just not that helpful. We only want to learn about errors. Is there a configuration for it? Of Course!

Just add
```
    stats: "errors-only"
```
to webpack.config.js


### Using source maps

It turns out that whenever our javascript has an error the error message in the browser isn't as helpful as it used to be? Why? Because it is showing us line-numbers from our transpiled code - not from the original code. There is a solution for that: Using source-maps.

It's easy to configure them for webpack. While we're developing we want to have sourcemaps but on production we don't want to have sourcemaps we'd rather like to have smaller files. So we're adding a switch to our webpack.config.js:

```
...
const isProd = process.env.NODE_ENV === 'production';

module.exports = {
    entry: './src/index',
    output: {
        filename: 'main.js',
        path: path.resolve(__dirname, 'dist')
    },
    stats: "errors-only",
    devtool: isProd ? "false" : "eval", # for production we don't want to have a sourcemap
    module: {
        loaders: [
...
};
```

And we'll also add another npm run script to build our application for production:

```
"scripts": {
  "build": "webpack",
  "release": "NODE_ENV=production webpack",
  "watch": "webpack --watch"
},
```

### Adding a bundle analyzer

Remember how we manually checked how our main.js file looks like? It turns out that there are bundle analyzers that give you statistics about your created bundle. That's helpful when you want to find out why your application is suddenly so big. Let's install one:

`npm i webpack-bundle-analyzer --save-dev`

And let's configure it in a way so that we can run `ANALYZE=true npm run build` to create the bundle and see the analysis' results:

```
const path = require('path');
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

const isProd = process.env.NODE_ENV === 'production';
const noop = function() {};

module.exports = {
    entry: './src/index',
    ...
    module: {
...
    },
    plugins: [
        new ExtractTextPlugin('main.css'),
        process.env.ANALYZE ? new BundleAnalyzerPlugin() : noop
    ]
};
```

It will open a browser window that we'll show us how our bundle looks like. And you'll notice that the biggest chunk is `react-dom.development.js`. Try running the analysis on the production bundle by running `ANALYZE=true npm run release` - it will yield the same result. But we don't want to use `react-dom.development.js` in our production bundle. How can we fix this?

### Using NODE_ENV=production

It turns out that we need to use yet another plugin to make sure that we're including the production build of react. That plugin is called `DefinePlugin`:

```
...
const webpack = require('webpack');

const isProd = process.env.NODE_ENV === 'production';
const noop = function() {};

module.exports = {
    entry: './src/index',
    output: {
        filename: 'main.js',
        path: path.resolve(__dirname, 'dist')
    },
    stats: "errors-only",
    devtool: isProd ? "false" : "eval",
    module: {
...
    },
    plugins: [
        new webpack.DefinePlugin({
            'process.env': {
                'NODE_ENV': JSON.stringify(process.env.NODE_ENV)
            }
        }),
        new ExtractTextPlugin('main.css'),
        process.env.ANALYZE ? new BundleAnalyzerPlugin() : noop
    ]
};
```

So what does it do? Let's say in our sourcecode we have the following line:

```
if (process.env.NODE_ENV === "production") {
    doSomethingCheap();
} else {
    doSomethingExpensive()
}
```

and we apply our plugin it will replace all occurences of `process.env.NODE_ENV` with the result of `JSON.stringify(process.env.NODE_ENV)` - which will be `"production"` if you run it in produciton mode.

So it will read like:
```
if ("production" === 'production') {
    doSomethingCheap();
} else {
    doSomethingExpensive()
}
```

It's quite obvious to us that we'll never reach the else branch here - and it is not only obvious to us but also to our tooling. In simplified terms that's the magic behind using the DefinePlugin.

Try analyzing the bundle for dev and prod again - you'll see that `react-dom.development.js` is no longer used in the produciton bundle.

### Minification

If you take a look at our resulting bundle `main.js` it looks quite big and it is also not minified. But this is an important optimization if you want a fast loading website. So let's add minifaction for the production bundle. Of course there is a plugin for that:

`npm i uglifyjs-webpack-plugin --save-dev`

And it is pretty easy to use that:

```
...
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
const webpack = require('webpack');

const isProd = process.env.NODE_ENV === 'production';

const noop = function() {};

module.exports = {
    ...
    module: {
        loaders: [
        ...
        ]
    },
    plugins: [
        new webpack.DefinePlugin({
            'process.env': {
                'NODE_ENV': JSON.stringify(process.env.NODE_ENV)
            }
        }),
        new ExtractTextPlugin('main.css'),
        isProd ? new UglifyJsPlugin() : noop, # we want to execute this one only for pruduction
        process.env.ANALYZE ? new BundleAnalyzerPlugin() : noop
    ]
};
```

### Gzip compression

Minification is just one step to a fast loading website. We can also compress our file contents. One such compression is gzip.
Most webservers like apache or nginx support compressing assets on the fly. But it is better to precompress files and [configure your server to use those precompressed files](http://nginx.org/en/docs/http/ngx_http_gzip_module.html#example).

So what we want is that alongside the `main.js` file we also have a file `main.js.gz` that contains the gzipped contents. And you guessed right: There is a plugin for that. Actually we should probably use `webpack-zopfli-plugin`. [So what the heck is Zopfli?](https://en.wikipedia.org/wiki/Zopfli) In short it is a compression that is compatible to gzip but makes files just a bit smaller.

`npm i zopfli-webpack-plugin --save-dev`

```
const path = require('path');
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
const ZopfliPlugin = require('zopfli-webpack-plugin');
const webpack = require('webpack');

const isProd = process.env.NODE_ENV === 'production';

const noop = function() {};

module.exports = {
    ...
    module: {
        ...
    },
    plugins: [
        ...
        isProd ? new UglifyJsPlugin() : noop,
        isProd ? new ZopfliPlugin() : noop,
        process.env.ANALYZE ? new BundleAnalyzerPlugin() : noop
    ]
};
```

If you run the `npm run release` now it will additionaly create a `main.js.gz`. Awesome.

### Caching with hashed file names

There is one more secret to fast pages. And that is caching. We'll use http caching and with that a browser has to download a file only once - when you reload the page it will detect that some files (like main.js) are already cached and it doesn't have to be downloaded again.

To enable caching you just have to configure some additional headers in your webserver. By adding a header like:

`cache-control: max-age=60`

Your telling your browser that it can cache the requested file for 60 seconds. Usually, you want that caching time to be really big. But then you get issues when you actually change something in `main.js` - browsers will then not use your new awesome code but the cached old version. There is one common way to fix this: giving the file a unique name and whenever the contents change you also change the filename. And webpack has easy support for that:

Just update your `webpack.config.js`:

```
const path = require('path');
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
const ZopfliPlugin = require('zopfli-webpack-plugin');
const webpack = require('webpack');

const isProd = process.env.NODE_ENV === 'production';

const noop = function() {};

module.exports = {
    entry: './src/index',
    output: {
        filename: '[name].[hash].js',
        path: path.resolve(__dirname, 'dist')
    },
    ...
    module: {
        ...
    },
    plugins: [
        ...
        new ExtractTextPlugin('main.[hash].css'),
        ...
    ]
};
```

Notice that we introduced `[hash]` this placeholder we be replaced with a unique hash. Our filenames now always change when we change any content and hence we can inifinitely cache our assets.

But we have 2 new problems:
The filename now changes all the time so we need to update our html page to include the right asset all the time. We're going to solve that later. And the other problem is that our build folder is getting fuller and fuller: With every change a new file is created and old once are not deleted. Let's fix that:

### Cleaning up the build folder

You probably already guessed it: We will use a plugin for that:

`npm i clean-webpack-plugin --save-dev`

and

```
...
const ZopfliPlugin = require('zopfli-webpack-plugin');
const CleanPlugin = require('clean-webpack-plugin');
...

module.exports = {
    ....
    module: {
        ...
    },
    plugins: [
        ...
        process.env.ANALYZE ? new BundleAnalyzerPlugin() : noop,
        new CleanPlugin(['dist'])
    ]
};
```

should do the trick. Now whenever we run `npm run build` it will first wipe our build folder so that we have a clean and empty folder.

### Using AssetsByTypePlugin to create and use an assets.json
Remember the second problem I mentioned? It's cumbersome to always update our html file to point to the correct file. But we can automate that. Instead of hard coded filenames in our index.html we can use some language (e.g. node.js) to dynamically inject javascripts. For that we need to now the names of those files that should be embedded.

And again there is a plugin for that:

`npm i webpack-assets-by-type-plugin --save-dev`

```
...
const AssetsByTypePlugin = require('webpack-assets-by-type-plugin');
...

module.exports = {
    ...
    module: {
        ...
    },
    plugins: [
        ...
        new CleanPlugin(['dist']),
        new AssetsByTypePlugin({
            path: path.join(__dirname, "dist/assets.json")
        }),
    ]
};
```

What this will do: whenever we build it will additionally create an assets.json that will look something like this:

```
{
    "js": [
        "main.9ccf1ec4793b5041cb5b.js"
    ],
    "css": [
        "main.9ccf1ec4793b5041cb5b.css"
    ]
}
```

We can now use that information to automatically embed those files instead of simply hardcoding `main.js` and `main.css`
But even for that task there is another plugin:

### Using HtmlWebpackPlugin Instead

If we don't want to code something ourselved to inject those scripts we can also just use `HtmlWebpackPlugin` which is giving us a development server and a way to automatically create an html file with all the needed scripts:

`npm i html-webpack-plugin --save-dev`

```
const AssetsByTypePlugin = require('webpack-assets-by-type-plugin');

...
    plugins: [
    ...
        new AssetsByTypePlugin({
            path: path.join(__dirname, "dist/assets.json")
        }),
        new HtmlWebpackPlugin()
    ]
};
```

We can now delete our handcrafted index.html file and we need to slightly adapt our index.js file:

By adding this line:
`document.body.innerHTML = '<div id="root"></div>';`
We make sure that we still have a div where we can mount our react application.

That's it. No need to manually update our html file anymore. We could now also remove the `AssetsByTypePlugin` - but we won't because in real world projects people also often skip the "remove unused stuff" part.

### Introducing dynamic-imports

After all this optimizing and refactoring our PO has yet another request:
The Analytics department found out that only 1% of visitors are actually clicking that button we've implemented. But ALL visitors download all that code that is only needed when we show all content. We should optimize that.

Luckily that's easy with using dynamic imports. A dynamic import is basically a way to only download sourcecode once it is needed.

Instead of `import hotel from './hotel'` at the top of the file we can do a dynamic import like `import('./hotel')` basically anywhere in our file. Once this code is executed it will yield us a Promise that will be fulfilled when the new code is downloaded.

So our code could then look something like this:

```
import React from 'react';
import ReactDOM from 'react-dom';
import ellipsize from 'ellipsize';
// note I've removed the hotel import from here

import './index.scss';

class App extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            hotel: false // we set the hotel state initially to false
        };
    }
    showHotel() {
        // this function is called when someone clicks the show button
        // when the code id downloaded our .then block will be called
        // in that block we're setting the state to what ./hotel exports
        import('./hotel').then((hotel) => {
            this.setState({ hotel: hotel });
        });
    }
    render() {
        //  here we check the state - do we have any hotel data?
        if (this.state.hotel) {
            const { name, description } = this.state.hotel;
            return (<div>
                <h1>{name}</h1>
                <p>{ellipsize(description)}</p>
            </div>);
        }
        return (<button onClick={this.showHotel.bind(this)}>Show Hotel</button>);
    }
}

document.body.innerHTML = '<div id="root"></div>';
ReactDOM.render(<App />, document.getElementById('root'));
```

If we do that you'll notice that our application is broken - because dynamic imports will not work out of the box. Babel has no clue what it should do with `import('./hotel')` - but we can teach it by using a plugin. This time it's not a webpack plugin. It is a babel plugin:

`npm i babel-plugin-syntax-dynamic-import --save-dev`

And because it is a babel plugin we don't configure it in our webpack.config.js but in our .babelrc:

```
{
    "presets": ["env", "react"],
    "plugins": ["syntax-dynamic-import"]
}
```

That's it. If we run our build again it works. And if you check in your browser you'll see that it starts downloading an additional file once we click on the button. Users who don't click the button don't have to download this additional source code. Great!

### build hash vs content hash
We could stop at this point. But once you dig a bit deeper you'll notice something strange. When you for example only change your CSS code it would be cool if only the css file name would change and users would still get the fully cached JavaScript files. But that's not the case. Whenever you change anything, all the filenames change. That's bad for caching.

There is an easy fix. It turns out that when we use the placeholder `[hash]` it is not generating a hash that is based on the contents of the file. Instead it is creating a unique hash for each build. If we switch to `[chunkhash]` it will really use the contents of the file to create the hash - the name only changes when the content of the file has changed:

```
module.exports = {
    entry: './src/index',
    output: {
        filename: '[name].[chunkhash].js',
        // I've also added the next line.
        // chunkFilename is the filename that is used for our dynamic imports
        chunkFilename: '[name].chunk.[chunkhash].js',
        path: path.resolve(__dirname, 'dist')
    },
```

For our CSS file it is a bit different. There the name of the placeolder is `[contenthash]`:

`new ExtractTextPlugin('main.[contenthash].css')`

So now when we change only our css only the css filename should change. And when we change our javascript only the javascript's filename will change. But there is more we could automate.

Most of the time projects start to add more and more external dependencies - for us that is now already `react`, `react-dom` and `ellipsize`. And whenever we change something in our real application code all this external - or vendor - code has to be downloaded again. But most of the time that part of the code has no changes.

Wouldn't it be cool if there would be a way to cache those vendor things separated? Let's create a vendor bundle:

### Using a vendor bundle

Webpack 3 has a namespace that is called `webpack.Optimizations` and one thing that's in their is the `CommonsChunkPlugin`. This plugin gives us a way to split our `main.js` file into multiple files - one with our application code and one with the code of our dependencies. We can easily do that by adding this to our plugins section in webpack.config.js:

```
new webpack.optimize.CommonsChunkPlugin({
    name: "vendor",
    minChunks: (m) => {
        return /node_modules/.test(m.context)
    }
})
```

So we've told webpack now that we want to have another bundle or chunk that is called `vendor` and we want that chunk to include all files that are required from our `node_modules` folder.

### Extracting the webpack manifest

### Making sure that only those file names change that really changed

### The final webpack.config.js

Our final webpack.config.js has 69 lines and looks like most configuration files: overly complicated and unmaintainable. But I still hope you could follow along and you know now WHY most of those configurations are needed and what benefit they give us.

```
const path = require('path');
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
const UglifyJsPlugin = require('uglifyjs-webpack-plugin');
const ZopfliPlugin = require('zopfli-webpack-plugin');
const CleanPlugin = require('clean-webpack-plugin');
const AssetsByTypePlugin = require('webpack-assets-by-type-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const webpack = require('webpack');

const isProd = process.env.NODE_ENV === 'production';

const noop = function() {};

module.exports = {
    entry: './src/index',
    output: {
        filename: '[name].[chunkhash].js',
        chunkFilename: '[name].chunk.[chunkhash].js',
        path: path.resolve(__dirname, 'dist')
    },
    stats: "errors-only",
    devtool: isProd ? "false" : "eval",
    module: {
        loaders: [
            {
                test: /\.js$/,
                use: 'babel-loader'
            },
            {
                test: /\.scss$/,
                use: ExtractTextPlugin.extract({
                    fallback: "style-loader",
                    use: [
                        "css-loader",
                        "sass-loader"
                    ]
                })
            }
        ]
    },
    plugins: [
        new webpack.DefinePlugin({
            'process.env': {
                'NODE_ENV': JSON.stringify(process.env.NODE_ENV)
            }
        }),
        new ExtractTextPlugin('main.[contenthash].css'),
        isProd ? new UglifyJsPlugin() : noop,
        isProd ? new ZopfliPlugin() : noop,
        process.env.ANALYZE ? new BundleAnalyzerPlugin() : noop,
        new CleanPlugin(['dist']),
        new AssetsByTypePlugin({
            path: path.join(__dirname, "dist/assets.json")
        }),
        new HtmlWebpackPlugin(),
        new webpack.optimize.CommonsChunkPlugin({
            name: "vendor",
            minChunks: (m) => {
                return /node_modules/.test(m.context)
            }
        }),
        new webpack.optimize.CommonsChunkPlugin({
          name: "manifest",
          minChunks: Infinity
        }),
        new webpack.NamedModulesPlugin()
    ]
};
```

### Improvements in webpack 4

Webpack 4 aims to reduce the configuration you need. For example you no longer need to configure an entry file and an output file - there are sane defaults to it. Also you don't need to use the `DefinePlugin` anymore and things like compression and dynamic imports have become easier. But it is still helpful to understand what webpack does for you. What tools like babel do. Why having chunks can be beneficial and why everything seems to be so damn complicated.

### Does it need to be so complicated?

Well a lot of people are complaining how complicated webdevelopment has gotten. They complain that they have to write those crazy webpack configs and install a trillion modules. But it is important to remember that you don't NEED to do that. The old way of just embedding tiny sprinkles of JS still works.

And even if you want all the benefits like minification, modern JavaScript, cachability and so on you could just use something like create-react-app or next.js

In one of the following posts in this blog we'll show you how easy it is to get started with next.js
